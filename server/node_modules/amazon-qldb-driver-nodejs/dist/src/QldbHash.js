"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var ion_hash_js_1 = require("ion-hash-js");
var ion_js_1 = require("ion-js");
var HASH_SIZE = 32;
/**
 * A QLDB hash is either a 256 bit number or a special empty hash.
 */
var QldbHash = /** @class */ (function () {
    /**
     * Creates a QldbHash.
     * @param qldbHash The QLDB hash.
     * @throws RangeError When this hash is not the correct hash size.
     */
    function QldbHash(qldbHash) {
        if (qldbHash.length !== HASH_SIZE || qldbHash.length === 0) {
            throw new RangeError("Hash must be either empty or " + HASH_SIZE + " bytes long.");
        }
        this._qldbHash = qldbHash;
    }
    /**
     * Sort the current hash value and the hash value provided by `that`, comparing by their **signed** byte values in
     * little-endian order.
     * @param that The Ion hash of the Ion value to compare.
     * @returns An QldbHash object that contains the concatenated hash values.
     */
    QldbHash.prototype.dot = function (that) {
        var concatenated = QldbHash._joinHashesPairwise(this.getQldbHash(), that.getQldbHash());
        var newHashLib = crypto_1.createHash("sha256");
        newHashLib.update(concatenated);
        var newDigest = newHashLib.digest();
        return new QldbHash(newDigest);
    };
    QldbHash.prototype.equals = function (other) {
        return (QldbHash._hashComparator(this.getQldbHash(), other.getQldbHash()) === 0);
    };
    QldbHash.prototype.getHashSize = function () {
        return this._qldbHash.length;
    };
    QldbHash.prototype.getQldbHash = function () {
        return this._qldbHash;
    };
    QldbHash.prototype.isEmpty = function () {
        return (this._qldbHash.length === 0);
    };
    /**
     * The QldbHash of an IonValue is just the IonHash of that value.
     * @param value The string or Ion value to be converted to Ion hash.
     * @returns A QldbHash object that contains Ion hash.
     */
    QldbHash.toQldbHash = function (value) {
        if (typeof value === "string") {
            var writer = ion_js_1.makeTextWriter();
            writer.writeString(value);
            writer.close();
            value = writer.getBytes();
        }
        var hashReader = ion_hash_js_1.makeHashReader(ion_js_1.makeReader(value), ion_hash_js_1.cryptoHasherProvider("sha256"));
        hashReader.next();
        hashReader.next();
        var digest = hashReader.digest();
        return new QldbHash(digest);
    };
    /**
     * Helper method that concatenates two Uint8Array.
     * @param arrays List of arrays to concatenate, in the order provided.
     * @returns The concatenated array.
     */
    QldbHash._concatenate = function () {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        var totalLength = 0;
        for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {
            var arr = arrays_1[_a];
            totalLength += arr.length;
        }
        var result = new Uint8Array(totalLength);
        var offset = 0;
        for (var _b = 0, arrays_2 = arrays; _b < arrays_2.length; _b++) {
            var arr = arrays_2[_b];
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    };
    /**
     * Compares two hashes by their **signed** byte values in little-endian order.
     * @param hash1 The hash value to compare.
     * @param hash2 The hash value to compare.
     * @returns Zero if the hash values are equal, otherwise return the difference of the first pair of non-matching
     *          bytes.
     * @throws RangeError When the hash is not the correct hash size.
     */
    QldbHash._hashComparator = function (hash1, hash2) {
        if (hash1.length !== HASH_SIZE || hash2.length !== HASH_SIZE) {
            throw new RangeError("Invalid hash.");
        }
        for (var i = hash1.length - 1; i >= 0; i--) {
            var difference = (hash1[i] << 24 >> 24) - (hash2[i] << 24 >> 24);
            if (difference !== 0) {
                return difference;
            }
        }
        return 0;
    };
    /**
     * Takes two hashes, sorts them, and concatenates them.
     * @param h1 Byte array containing one of the hashes to compare.
     * @param h2 Byte array containing one of the hashes to compare.
     * @returns The concatenated array of hashes.
     */
    QldbHash._joinHashesPairwise = function (h1, h2) {
        if (h1.length === 0) {
            return h2;
        }
        if (h2.length === 0) {
            return h1;
        }
        var concatenated;
        if (this._hashComparator(h1, h2) < 0) {
            concatenated = this._concatenate(h1, h2);
        }
        else {
            concatenated = this._concatenate(h2, h1);
        }
        return concatenated;
    };
    return QldbHash;
}());
exports.QldbHash = QldbHash;
